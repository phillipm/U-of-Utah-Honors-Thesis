\chapter{INTRODUCTION}\label{ch:intro}
This blog contains my study notes on the Curry-Howard Isomorphism (C-H) and the broader field of Programming Languages. While much material on C-H exists, most of it expects domain expertise from the reader. My goal is to present an undergraduate level introduction of C-H. I am in no way an expert in this field and thus mistakes are inescapable, please be kind and point them out.


\section{What is the Curry-Howard Isomorphism? (hand wavy version)}
The Curry-Howard Isomorphism states that there is a direct correspondence between intuitionistic logic and typed lambda calculus.

More specifically a type declaration given in a programming language corresponds to a logical proposition and an implementation of that type declaration is a proof of that proposition.

\emph{A Simple Example:}
The Haskell type signature for the function const
\begin{verbatim}
const :: a -> b -> a
\end{verbatim}

is equivalent to the logical proposition
\begin{equation*}
\frac{\Gamma, \alpha \vdash \beta}{\Gamma \vdash \alpha \rightarrow \beta \rightarrow \alpha}
\end{equation*}

And since we are using a restricted form of logic known as intuitionistic or constructivist logic, providing a well-typed implementation to the function's type signature is the same as giving a logical proof.
%<pre><font color="Blue">const</font> a b <font color="Red">=</font> a</pre>

The example above is somewhat uninteresting since it deals with first-order logic. However, later I will show how the Curry-Howard Isomorphism holds for higher levels of logic as well.

\section{Why is this interesting?}
C-H sounds kind of interesting, but one might ask how it is useful?

C-H isn't really useful for the average programmer. Regardless, researchers are coming up with crazy new programming languages that make use of C-H. Cayenne and Omega for example use dependent types, which correspond to higher-order logic.

Additionally, C-H has let mathematicians and computer scientists benefit from each other's discoveries. Computer scientists have traditionally researched reductions in lambda-calculus, while mathematicians have worked on normalization in proof theory. Thus, a discovery in one domain directly translates into the other domain. (pg. 67 of \cite{CHnotes})

My interest in C-H started when I wanted to create a system to generate functions given a type signature and example input-output pairs. The problem is too under-determined to be plausible, but using more advanced type systems and leveraging C-H might mitigate that.
